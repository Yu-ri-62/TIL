## 배열2

### 2차원 배열

#### 2차원 배열의 선언

* 1차원 list를 묶어놓은 list
* 2차원 이상의 다차원 list는 차원에 따라 index를 선언
* 2차원 list 선언: 세로길이(행의 개수),  가로길이(열의 개수)를 필요로 함.
* Python에서는 데이터 초기화를 통해 변수선언과 초기화가 가능함.

#### 배열 순회

* n X m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법

* __행 우선 순회__

```python
# i 행의 좌표
# j 열의 좌표
for i in range(len(Array)):
    for j in range(len(Array[i])):
        Array[i][j]  # 필요한 연산 수행
```

* __열 우선 순회__

```python
# i 행의 좌표
# j 열의 좌표
for i in range(len(Array[0])):
    for j in range(len(Array)):
        Array[j][i]  # 필요한 연산 수행
```

* __지그재그 순회__

```python
# i 행의 좌표
# j 열의 좌표
for i in range(len(Array)):
    for j in range(len(Array[0])):
        Array[i][j + (m-1-2*j) * (i % 2)]
        #  필요한 연산 수행
```

* __델타를 이용한 2차 배열 탐색__

```python
ary[0...n-1][0...n-1]
dx[] <- [0, 0, -1, 1]  # 상하좌우
dy[] <- [-1, 1, 0, 0]

for x in range(len(ary)):
    for y in range(len(ary[x])):
        for i in range(4):
            testX <- x + dx[mode]
            testY <- y + dy[mode]
            test(ary[testeX][testY])
```

* 전치행렬

```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]   # 3 * 3 행렬
for i in range(3):
    for j in range(3):
        if i < j :
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```





### 부분집합 

#### 부분집합 합(Subset Sum) 문제

* 유한 개의 정수로 이루어진 잡합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제

#### 부분집합 생성하기

* 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는, 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.
* __부분집합의 수__
  * 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2^n개이다.

  * 각 원소가 부분집합에 포함되었는지를 loop이용하여 확인하고 부분집합을 생성하는 방법

    ```python
    bit = [0,0,0,0]
    for i in range(2):
        bit[0] = i                 # 0번째 원소
        for j in range(2):
            bit[1] = j             # 1번째 원소
            for k in range(2):
                bit[2] = k         # 2번째 원소
                for l in range(2):
                    bit[3] = l     # 3번째 원소
                    print(bit)     # 생성된 부분집합 출력
    ```



#### 비트 연산자

* `&` : 비트 단위로 AND 연산을 한다.

* `|` : 비트 단위로 OR 연산을 한다.

* `<<` : 피연산자의 비트 열을 왼쪽으로 이동시킨다.

  * 1<<n: 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

* `>>` : 피연산자의 비트 열을 오른쪽으로 이동시킨다.

  * i&(1<<j): i의 j번째 비트가 1인지 아닌지를 리턴한다.

* __간결하게 부분집합을 생성하는 방법__

  ```python
  arr = [3,6,7,1,5,4]
  n = len(arr)              # n: 원소의 개수
  for i in range(1<<n):     # 1<<n: 부분 집합의 개수
      for j in range(n+1):  # 원소의 수 만큼 비트를 비교함
          if i & (1<<j):    # i의 j번째 비트가 1이면 j번째 원소 출력
              print(arr[j], end=", ")
       print()
  print()
  ```

  



### 검색(Search)

* 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업
* 목적하는 탐색 키를 가진 항목을 찾는 것
  * 탐색 키(search key): 자료를 구별하여 인식할 수 있는 키
* 검색의 종류
  * 순차 검색(sequential search)
  * 이진 검색(binary search)
  * 해쉬(hash)

#### 순차검색

* 일렬로 되어 있는 자료를 순서대로 검색하는 방법

  * 가장 간단하고 직관적인 검색 방법
  * 배열이나 연결 리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
  * 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가하여 비효율적임

* 2가지 경우

  * 정렬되어 있지 않은 경우

    * 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.

    * 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.

    * 자료구조의 마지막에 이를 때 까지 검색 대상을 찾지 못하면 검색 실패

      ```python
      def sequentialSearch(a, n, key):
          i <- 0
          while i < n and a[i] != key:
              i <- i+1
          if i < n:
              return i
          else:
              return -1
      ```

      

  * 정렬되어 있는 경우

    * 자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정하자.

    * 자료를 순차적으로 검색하면서 키 값을 비료하여 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료한다.

      ```python
      def sequentialSearch(a, n, key):
          i <- 0
          i <- i+1
          while i < n and a[i] < key:
              i <- i+1
          if i < n and a[i] = key:
              return i
          else:
              return -1
      ```



#### 이진 검색

* 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

  * 목적 키를 찾을 때 까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함

* 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

* 검색과정

  * 자료의 중앙에 있는 원소를 고른다.

  * 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.

  * 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.

  * 찾고자 하는 값을 찾을 때까지 앞의 과정을 반복한다.

    ```python
    # 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행한다.
    # 이진 검색의 경우, 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요하다.
    def binarySearch(a, key):
        start <- 0 end <- length(a)-1
        while start <= end:
            middle = (start + end)//2
            if a[middle] == key:  # 검색 성공
                return True
            elif a[middle] > ky:
                end = middle -1
            else:
                start = middle + 1
        return False              # 검색 실패
    ```

    ```python
    # 재귀 함수 이용
    def binarySearch2(a, low, high, key):
        if low > high:    # 검색 실패
            return False
        else:
            middle = (low + high) // 2
            if key == a[middle]:  # 검색 성공
                return True
            elif key < a[middle]:
                return binarySearch2(a, low, middle-1, key)
            elif a[middle] < key:
                return binarySearch2(a, middle+1, high, key)
    ```



### 셀렉션 알고리즘(SelectionAlgorithm)

* 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
  
  * 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.
* 선택과정
  * 정렬 알고리즘을 이용하여 자료 정렬하기
  * 원하는 순서에 있는 원소 가져오기

* k번째로 작은 원소를 찾는 알고리즘

  * 1번부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 k번째를 반환한다.

    ```python
    def select(list, k):
        for i in range(0, k):
            minIndex = i
            for j in range (i+1, len(list)):
                if list[minIndex] > list[j]:
                    minIndex = j
            list[i], list[minIndex] = list[minIndex], list[i]
        return list[k-1]
    ```

    

### 선택 정렬(Selection Sort)

* 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식

* 정렬 과정

  * 주어진 리스트 중에서 최소값을 찾는다.

  * 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.

  * 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.

    ```python
    def SelectionSort(a[], n):
        for i from 0 to n-1:
            a[i],...,a[n-1]  # 원소 중 최소값 a[k] 찾음
            a[i]와 a[k] 교환
    ```

    ```python
    def SelectionSort(a):
        for i in range(0, len(a)-1):
            min = i
            for j in range(i+1, len(a)):
                min = j
            a[i], a[min] = a[min], a[i]
    ```

    

